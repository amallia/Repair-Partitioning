#ifndef PARTITIONING_H
#define PARTITIONING_H

#include <vector>
#include <string>
#include <ostream>
#include <iostream>
#include <unordered_map>
#include <set>
#include <assert.h>
#include "../util/md5.h"
#include "../repair-algorithm/RepairTreeNode.h"

struct FragInfo;

class SortNodesByOffsetComparator
{
public:
	bool operator() (const RepairTreeNode* const lhs, const RepairTreeNode* const rhs) const
	{
		return lhs->getOffset() < rhs->getOffset();
	}
};

typedef std::multiset<RepairTreeNode*, SortNodesByOffsetComparator> SortedByOffsetNodeSet;

class RepairDocumentPartition
{
	unsigned method;

	float fragmentationCoefficient;

	unsigned numLevelsDown;

	unsigned minFragSize;

	unsigned maxNumCalls;
	
	unsigned numCallsSoFar;

	// The list of associations generated by repair
	std::unordered_map<unsigned, Association> associations;

	// The outer vector represents all versions
	// The vector at position i contains fragment objects for version i
	std::vector<std::vector<FragInfo > > fragments;

	// Unique Fragments in all the versions
	std::unordered_map<std::string, FragInfo> uniqueFrags;

	// One implementation of get partitioning for one version
	SortedByOffsetNodeSet getNodesNthLevelDown(RepairTreeNode* root, unsigned numLevelsDown, SortedByOffsetNodeSet& nodes);

	// Another one, greedy approach
	SortedByOffsetNodeSet getBestSubset(RepairTreeNode* node, int numLevels, bool& tooManyCalls);

	double getSubsetScore(SortedByOffsetNodeSet subset);

	// Populates unique frags using the boundaries found by the partitioning algorithm
	// void updateUniqueFragmentHashMap();

	// Populates this->fragments
	void setFragmentInfo(const std::vector<std::vector<unsigned> >& versions, std::ostream& os, bool print);
public:
	enum Method { NAIVE, GREEDY };

	RepairDocumentPartition(
		std::unordered_map<unsigned, Association>& associations,
		unsigned numVersions, 
		unsigned numLevelsDown = 1, 
		unsigned minFragSize = 2,
		float fragmentationCoefficient = 1.0,
		unsigned method = 1)
		 :
		associations(associations),
		numLevelsDown(numLevelsDown), 
	 	minFragSize(minFragSize),
	 	fragmentationCoefficient(fragmentationCoefficient),
	 	method(method)
	{
		fragments = std::vector<std::vector<FragInfo > >();
		uniqueFrags = std::unordered_map<std::string, FragInfo>();
		maxNumCalls = 100;
		numCallsSoFar = 0;
	}

	// Cuts one version
	void getPartitioningOneVersion(RepairTreeNode* root, 
		std::vector<unsigned>& bounds, unsigned versionSize);
};

#endif
